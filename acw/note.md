# ACW

## 穷竭搜索

1. 深度优先搜索，用栈来模拟，或者递归；
2. 广度优先搜索，用队列来模拟；

### 深度优先搜索

* POJ 1979: 长方形地图分隔成方块，方块涂成红黑两色，人初始在黑块上，不能踩红块，计算所有能到达的点；深度、广度搜索；
* AOJ 0118: M * N 矩阵种满植物，相邻同种植物可以划归到一起，求总共能划成几块；从未划归的点开始深度搜索，上下左右相邻同种植物皆标记为当前块；
* AOJ 0033: 1 到 10 编号的 10 个球给定顺序，依次落入两个队列中，问是否存在最终两个队列都是小球在大球之上的方案；贪心算法，优先落在较大队列上；
* POJ 3009: 长方形地图内有障碍，有初始点与终止点，球可四个方向无摩擦运动直至：1. 遇到障碍停下，打碎障碍；2. 出界；3. 终点，求到达终点最少抛掷次数；深度优先搜索；

### 宽度优先搜索

* AOJ 0558: M * N 矩阵中有 K 个点编号 1 至 K，求从起点顺序经历 1 到 K 各点最短路径；任意两点之间都使用广度优先找到最短路径；
* POJ 3669: 给出 M 个流星的落点坐标和时间，流星会摧毁落点和上下左右四点，从原点出发，求安全撤离路径；按照步数广度优先搜索，直至一个平安点；
* AOJ 0121: 0 到 7 八个数字排两行，初始任意局面，走一步为 0 和相邻数字交换，求最终形成上 0123 下 4567 局面的最小步数；从初始局面开始，广度遍历所有局面；

### 穷竭搜索

* POJ 2718: 一组不重复的数字，可将其分为两组组成两个数字，求两个数字最小的差；用递归求数字的全排列，每一个排列从中间劈成两半，求两数差；
* POJ 3187: 给出 1 到 N 共 N 个数的排列，循环求相邻两数之和，直至剩一个数；给定 N 和最后这个数，求 1 至 N 的排列；遍历全排列；
* POJ 3050: 5 * 5 的数字矩阵，求从任意点出发走 6 步，总共能得到几个不同的数；对每一个点，深度遍历所有可能的路径，组合到的数字加入集合；
* AOJ 0525: R * C 矩阵，R <= 10，每个位置为 0 或 1，可以对整行或整列进行反转，求最多可以有多少个 0；由于 R 小，对 R 进行翻与不翻的全排列，每个排列中列调整为 0 最多；

## 贪心算法

### 区间贪心

* POJ 2376: T 个区间，用 N 个区间段覆盖，求最小区间段个数能全部覆盖；将区间段按照开头排序，从最左端开始，贪心取能覆盖左端且最右的区间段；
* POJ 1328: x 轴上方 n 个岛，x 轴上放置半径为 d 的雷达，求覆盖所有岛最少雷达数；n 个岛换算成 x 轴上 n 个区间，按照区间右端排序，从左到右安装雷达；
* POJ 3190: n 头牛各自有产奶区间，产奶时必须独占牛栏，求最少牛栏数；将产奶时间按开始时间排序，按占用牛栏截止时间将牛栏组织在优先队列里，优先安排已释放牛栏，否则新建；

### 其他贪心

* POJ 2393: 给定每天产奶成本，每天需求量，存储一份牛奶一天的固定花费 S，求最小成本的生产计划；每天对比当天或前面 N 天生产本日需求的成本取最小，最终成本即最小；
* POJ 1017: 给出边长为 1 至 6 的正方形若干，求用最少的边长为 6 的正方形装下他们；从大到小六个数字分别处理，每次装箱都尽量贪心装最多；
* POJ 3040: 给出不同面值的硬币，小面值总是可以整除大面值，给出每日花费常量，硬币不可分割，求可支付多少日；每次优先拿不超过 C 的大硬币，若不足则从小到大拿硬币来补；
* POJ 1862: n 个细胞，质量为 m1 m2 的结合后会变成质量为 2 * sqrt(m1 * m2) 的新细胞，求最后形成的终极细胞的最小质量；每次拿最大的两个来结合；
* POJ 3262: 每头牛牵回牛棚需要不同的时间，在回去前单位时间会破坏不同数量的草，求最少破坏多少草；每次选择一个牛，使得牵回它时整体破坏最少；

## 动态规划

0. 使用滚动数组进行降维优化空间复杂度；01 背包问题从后向前更新，完全背包问题从前向后更新，相当于链式求 Max；
1. 01 背包问题，N 个物品，第 i 个重量为 w[i]，价值为 v[i]，背包最多装 V 重量；动态规划装 i 和不装 i 两种情况：f[i][v] = max(f[i-1][v], f[i-1][v-w[i]] + v[i])；
2. 完全背包问题，每个物品可以有无限个：动态规划物品 i 装 0, 1, ..., floor(V/w[i]) 全部情况；动态数组从前向后更新，简化递推式子；
3. 多重背包问题，每个物品可以有 n[i] 个：将第 i 个物品表示为 1 倍体，2 倍体,... 2^(k-1) 倍体和 n[i]-2^(k-1) 这几个物体，使用 01 背包来解决；
4. 二维费用 V1, V2，或限制总物品数 M(相当于第二维费用统一都是 1，总费用限制为 M)：使用二维数组来表示两个费用；
5. 分组背包：N 个物品分为 K 组，每组只能取一个：对于每一组，对于不超过费用 V...0 各种情况，依次尝试选择组内第 i 个物品；
6. 求第 K 优解：背包问题的状态表示为一个 K 个元素的数组，保存前 K 高的解，状态转义时，max() 函数为将两个数组合并之后取前 K 项；

### 基础DP

* POJ 3176: 若干个数摆成三角，每次可以从上一层移动到下一层最近的两个点，求自顶向下的路径和最大值；每一行所有可能到达的点，其最大值为上一行可达点的最大值加本点；
* POJ 2229: 将一个数 n 分解为 2 的次幂的和，求分解方案数；若为奇数，则方案数为 n+1 分解方案数；若为偶数，则方案数为 n-2 和 n/2 两个数分解方案数之和；
* POJ 2385: 苹果每分钟从两棵树的其中一棵落下，在树 1 和树 2 间可以跳换给定 N 次，问最多可以接到多少苹果，初始在树 1；对每分钟，考虑前一分钟跳换 j 或 j - 1 次；
* POJ 3616: N 个时间区间每个区间包含一个价值，选中的任意两个区间间相隔至少 R，求最大价值；区间按结束时间排序，从后往前，对该区间，求相隔 R 及以上前面区间最大值；
* POJ 3280: 给定字符串任意位置可以增加或删除字符，已知每个字符增删代价，求字符串变回文的最小代价；增删代价取最小，对每一个可能的对称轴，向左右发展；

### 优化递推式

* POJ 1742: 每种面值 A[i] 的硬币各有 C[i] 个，求构成不大于 M 的面值可能性；是一个多重背包问题，用数组 f[i][v] 表示考虑到硬币 i 时，构成面值 v 是否可能；
* POJ 3046, 3181: 都是背包问题的变形；

# Algorithms 4e

1. GCD: Euclid's Algorithm, 循环大数除小数
2. SQRT: Newton's Method, 循环 xNew = ( xOld + x/xOld )/2，直至 xOld 和 x/xOld 相差小于阈值
3. Arithmetic Expression (((2 - 5) + 1) * 2): Dijkstra's Double Stack, 一个操作符栈，一个操作数栈，可转后缀表达式
4. Editor Buffer: 支持插入删除左移右移, 用两个栈头对头，左右移动时一个栈出一个栈进
5. Reverse a Linked List: 开一个新链表头，模拟旧链表出栈新链表入栈；可以用递归
6. 调和级数 1 + 1/2 + 1/3 + ... + 1/N ~ lnN
7. 斯特灵估计 lgN! ~ NlgN，该估计从斯特灵公式得来
8. 二项式系数，当 k 相对小时 C(N, k) ~ N^k/k!，其中 N(N-1)(N-2)...(N-k+1) ~ N^k
9. (1-1/x)^x ~ 1/e
10. 一维数组 N 个不同的数字，找到一个局部最小值：使用二分搜索，因为若中点非局部最小，则小的一侧至少存在一个局部最小；
11. 测试鸡蛋从几层楼摔下不会破的问题，如果鸡蛋很多，可以二分搜索；如果只有两个鸡蛋，可以按照 sqrt(N), 2sqrt(N), ..., sqrt(N)sqrt(N) 测试第一个，测到底线之后另一个线性扔；
12. 选择排序和插入排序，前者运行时间和输入顺序无关，后者在输入基本有序的情况下更优；输入基本有序时，优先考虑插入排序；
13. Shell 排序是插入排序的一个扩展，每次把相隔 h 的元素组成的子序列排序，大循环内减少 h，当 h 为 1 时全局就已排序；h 可以选择 h=3h+1 这样的序列递减；
14. MergeSort 需要一块额外数组，轮换角色法可以减少数组来回拷贝次数；另一个优化是子数组长度小时，使用插入排序，一般长度小于 15 时使用插入排序；Merge 之前检查要 Merge 两个数组，如果一个的最大值小于另一个的最小值，则可以省去一次 Merge；
15. MergeSort 复杂度可以用比较的次数来衡量，每次循环比较次数上限均为 N，循环次数为 lgN，因此复杂度 NlgN；此外，基于比较的排序比较次数不能低于 NlgN；
16. 自底向上写循环进行归并排序，每 2、4、8... 分组依次向上归并，还可以处理链表的排序；还可以使用一个队列，初始队列中是 N 个队列，各含一个元素，循环每次取前两个队列合并；
17. QuickSort 和 MergeSort 相比：前者先按照参考值把数组划分成两部分，然后递归排序两部分；后者先对半划分，然后递归排序两部分，最后合并两部分；
18. QuickSort 的最优情况是每次参考值恰好把数组对半分；几个优化：长度小的数组用插入排序，或忽略小数组，最后统一插入排序一次；每次选取一个小样本，用样本中值作为参考值；
19. 对于存在大量重复 Key 的情况，QuickSort 的一个优化是进行三路分区，选取参考值后，将数组分为小于、等于、大于三部分；3-Way QuickSort 通常是排序库函数实现；
20. 用栈来实现非递归的 QuickSort，每次 Devide 之后，把大小两个子数组压栈，中间压入参考值；
21. 用数组表示的完全二叉树实现大顶、小顶堆，从下标 1 开始存数据编码方便很多，实现优先队列 PQ 很方便；
22. Index PQ 实现 N 路 stream 归并：用大小为 N 的 PQ，每一路 stream 存一个元素进来，每次输出堆顶元素之后，再从对应 stream 里读新元素进来；
23. 堆排序过程：自右向左，从 N/2 到 1 为堆顶，用 sink() 构造大顶堆；然后每次取出堆顶元素放在堆末尾，堆大小减一，原来末尾的元素放在堆顶进行 sink()；
24. 插入排序和归并排序是稳定的，选择、希尔、快速、堆排序是不稳定的；比较元素时先比较值，再比较其 index，可以把不稳定排序变成稳定排序；
25. shuffle 的一个简单实现：从数组开头开始，对于第 i 个元素，都和 i 之后的一个随机元素互换位置；
26. 一个基于 QuickSort 方法的选择第 K 个元素算法：先 shuffle 数组，然后每次用 QuickSort 同样的办法进行 partition，如果 partition 得到的分界 j 即为 K，则返回元素，否则如果 j 小于 K，在 j+1 及之后的数组上重复，如果 j 大于 K，在开头到 j-1 的数组上重复算法；
27. 8 puzzle: 用 A\* 算法，初始状态放入优先队列，从初始状态生成所有邻居状态，按照汉明距离或者汉密尔顿距离放入优先队列，每次从队列头生成邻居状态，直至最终状态；
28. Binary Search Tree BST 的删除：找到要删除的节点 x，如果子树少于两棵，直接用子树替代 x 即可；如果有两棵子树，提升左子树中最大者，或者右子树中最小者；
29. Red-Black Tree BST 的插入：插入的节点为红色，红色向上传递，用递归实现（左黑右红左旋；左红红右旋；左右红反转），最后把根节点标记为黑色；
30. Red-Black Tree BST 的删除：基于删除最小实现，如果要删除的节点是叶节点，直接子树删除最小，否则用右子树最小值替代本节点，删除右子树最小；
31. Red-Black Tree BST 删除最小：自上而下搜索时，调整当前节点不是黑色，删除最小之后，自下而上重新调整不合规范的红色节点；
32. Red-Black Tree BST 的插入、删除、查找等操作均可达到对数复杂度，是常用的 Symbol Table 实现；
33. 取模做 Hash 时，模要取素数，否则被模的元素中总有部分数位无法被利用；
34. Hash 冲突两个常见解决办法：一个是每个 Hash 位都存放一个链表ST，叫做 Separate Chaining；另一个是冲突之后向后寻找空位，此时需要维护数组长度，经常 Resize；
35. 用 SymbolTable 实现 List，一个 ST 用来追踪索引 i 到 item；另一个 ST 用来追踪 item 本身；
36. UniQueue，实现一个 Queue，并用一个 ST 来追踪 Queue 中的元素，enqueue 和 dequeue 的时候分别查询和删除 ST；
37. Union-Find: 先构建图，然后用搜索方法在图中找出联通区域；第一章的加权森林法，用数组表示链接，c[i]=j 表示 i 指向 j，再用数组保存距离跟节点的距离，总是把小树连到大树上；
38. 有向图环检测：用深度优先遍历，遍历时维护一个 marked 数组和一个 onStack 数组，把遇到的点都标记为 marked 和 onStack，在处理完一个点之后取消 onStack 标记；遍历过程中遇到已经 onStack 的点，则说明有环；如果要返回具体环的路径，则记录一个 edgeTo 数组，追踪当前点是从那里指向来的，检测到环时按照 edgeTo 恢复路径；
39. 有向图拓扑排序：深度优先遍历，在递归调用之后将节点 push 进一个 stack，最后弹出 stack 即为拓扑排序的一个结果；从任意节点开始遍历都可以；
40. 有向图强连通检测：首先，在 Reverse 图上找一个拓扑排序顺序，然后，按照该顺序进行深度优先遍历；Reverse 图上面的拓扑排序中，若 v 排在 w 后面，则说明在原图中 v 到 w 可达，而如果从 w 开始深度遍历访问到了 v，则 v 和 w 就一定位于同一个强连通区域里；
41. 加权无向图的最小生成树贪心规则：对于图的任意一个子图，连接子图和子图的补图的所有边中，权重最小的边一定在生成树里；
42. 加权无向图的最小生成树 Prim 算法：从任意节点开始构造子图，用优先队列保存该子图所有对外的边，选择最小的边，把对应的节点加入子图，直至所有节点都已经进来；
43. 加权无向图的最小生成树 Kruskal 算法：用优先队列保存所有边，每次选择最小的边，如果引入该边不构成环，则引入，直至选够节点数 V-1 个边位置；其中构成环判断可以用 Union-Find 算法；
44. 加权有向图的最短路径 Dijkstra 算法(非负权重)：从源点 s 开始，distTo[] 数组表示各点到 s 的距离，初始 distTo[s] 为零，其它为正无穷；将可达的边按照 distTo[] 排序加入优先队列，每次取最短可达的边，relax 其可达的顶点，然后将该顶点可达的边也加入优先队列；
45. Key-Indexed Counting 适用于 Sorting Key 为小范围整数的情况：1. 遍历对 Key 计数生成 cnt[]；2. 通过 cnt[i] += cnt[i-1] 计算每个 Key 的起始点；3. 遍历，根据起始点放置元素；4. 元素拷贝回原数组，实现排序；
46. 等长字符串排序：字符串长度为 K，则从右到左做 K 次 Key-Indexed Counting 排序；因为 Key-Indexed Counting 排序是稳定的，所以可行；
47. 任意字符串排序：从前向后按照字符进行 Key-Indexed Counting 排序，然后对于相同开头的字符串，递归排序其剩余部分；对于小的子字符串集合，切换为插入排序来题高性能；
48. Trie: 实现一种字符串为 Key 的 Symbol Table，使用树形结构 Share Key Prefix；每个节点上的 N 维数组指向后继节点，节点有值表示对应的 Key 有 Value；
49. Ternary Search Tries: 每个节点有一个值，表示当前字符；有三个链接，左边指向比当前字符小的节点，右边指向比当前字符大的节点，中间则指向当前字符顺下去的节点；
50. KMP 字符串搜索算法：首先，为 Pattern 字符串构建一个 dfa，dfa[c][j] 代表遇到字符 c 时，如果位于 Pattern 第 j 个字符，下一步应该对比 Text(i+1) 和 Pattern(dfa[c][j])；以达到 M+N 的最坏搜索复杂度；构建 dfa 数组通过追踪重启状态点 X 进行，状态点 X 的转移方程为 X = dfa[Pattern(j)][X]；
51. Boyer-Moore 字符串搜索算法：从右往左对比 Pattern 和 Text，当遇到不匹配时，将 Pattern 右移到当前不匹配字符第一次出现的地方；
52. Rabin-Karp 指纹搜索：通过快速取模的哈希算法，线性求子串的哈希值，和 Pattern 的哈希值进行对比；

# LeetCode

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；

