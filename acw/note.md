# ACW

## 穷竭搜索

1. 深度优先搜索，用栈来模拟，或者递归；
2. 广度优先搜索，用队列来模拟；

### 深度优先搜索

* POJ 1979: 长方形地图分隔成方块，方块涂成红黑两色，人初始在黑块上，不能踩红块，计算所有能到达的点；深度、广度搜索；
* AOJ 0118: M * N 矩阵种满植物，相邻同种植物可以划归到一起，求总共能划成几块；从未划归的点开始深度搜索，上下左右相邻同种植物皆标记为当前块；
* AOJ 0033: 1 到 10 编号的 10 个球给定顺序，依次落入两个队列中，问是否存在最终两个队列都是小球在大球之上的方案；贪心算法，优先落在较大队列上；
* POJ 3009: 长方形地图内有障碍，有初始点与终止点，球可四个方向无摩擦运动直至：1. 遇到障碍停下，打碎障碍；2. 出界；3. 终点，求到达终点最少抛掷次数；深度优先搜索；

### 宽度优先搜索

* AOJ 0558: M * N 矩阵中有 K 个点编号 1 至 K，求从起点顺序经历 1 到 K 各点最短路径；任意两点之间都使用广度优先找到最短路径；
* POJ 3669: 给出 M 个流星的落点坐标和时间，流星会摧毁落点和上下左右四点，从原点出发，求安全撤离路径；按照步数广度优先搜索，直至一个平安点；
* AOJ 0121: 0 到 7 八个数字排两行，初始任意局面，走一步为 0 和相邻数字交换，求最终形成上 0123 下 4567 局面的最小步数；从初始局面开始，广度遍历所有局面；

### 穷竭搜索

* POJ 2718: 一组不重复的数字，可将其分为两组组成两个数字，求两个数字最小的差；用递归求数字的全排列，每一个排列从中间劈成两半，求两数差；
* POJ 3187: 给出 1 到 N 共 N 个数的排列，循环求相邻两数之和，直至剩一个数；给定 N 和最后这个数，求 1 至 N 的排列；遍历全排列；
* POJ 3050: 5 * 5 的数字矩阵，求从任意点出发走 6 步，总共能得到几个不同的数；对每一个点，深度遍历所有可能的路径，组合到的数字加入集合；
* AOJ 0525: R * C 矩阵，R <= 10，每个位置为 0 或 1，可以对整行或整列进行反转，求最多可以有多少个 0；由于 R 小，对 R 进行翻与不翻的全排列，每个排列中列调整为 0 最多；

## 贪心算法

### 区间贪心

* POJ 2376: T 个区间，用 N 个区间段覆盖，求最小区间段个数能全部覆盖；将区间段按照开头排序，从最左端开始，贪心取能覆盖左端且最右的区间段；
* POJ 1328: x 轴上方 n 个岛，x 轴上放置半径为 d 的雷达，求覆盖所有岛最少雷达数；n 个岛换算成 x 轴上 n 个区间，按照区间右端排序，从左到右安装雷达；
* POJ 3190: n 头牛各自有产奶区间，产奶时必须独占牛栏，求最少牛栏数；将产奶时间按开始时间排序，按占用牛栏截止时间将牛栏组织在优先队列里，优先安排已释放牛栏，否则新建；

### 其他贪心

* POJ 2393: 给定每天产奶成本，每天需求量，存储一份牛奶一天的固定花费 S，求最小成本的生产计划；每天对比当天或前面 N 天生产本日需求的成本取最小，最终成本即最小；
* POJ 1017: 给出边长为 1 至 6 的正方形若干，求用最少的边长为 6 的正方形装下他们；从大到小六个数字分别处理，每次装箱都尽量贪心装最多；
* POJ 3040: 给出不同面值的硬币，小面值总是可以整除大面值，给出每日花费常量，硬币不可分割，求可支付多少日；每次优先拿不超过 C 的大硬币，若不足则从小到大拿硬币来补；
* POJ 1862: n 个细胞，质量为 m1 m2 的结合后会变成质量为 2 * sqrt(m1 * m2) 的新细胞，求最后形成的终极细胞的最小质量；每次拿最大的两个来结合；
* POJ 3262: 每头牛牵回牛棚需要不同的时间，在回去前单位时间会破坏不同数量的草，求最少破坏多少草；每次选择一个牛，使得牵回它时整体破坏最少；

## 动态规划

0. 使用滚动数组进行降维优化空间复杂度；01 背包问题从后向前更新，完全背包问题从前向后更新，相当于链式求 Max；
1. 01 背包问题，N 个物品，第 i 个重量为 w[i]，价值为 v[i]，背包最多装 V 重量；动态规划装 i 和不装 i 两种情况：f[i][v] = max(f[i-1][v], f[i-1][v-w[i]] + v[i])；
2. 完全背包问题，每个物品可以有无限个：动态规划物品 i 装 0, 1, ..., floor(V/w[i]) 全部情况；动态数组从前向后更新，简化递推式子；
3. 多重背包问题，每个物品可以有 n[i] 个：将第 i 个物品表示为 1 倍体，2 倍体,... 2^(k-1) 倍体和 n[i]-2^(k-1) 这几个物体，使用 01 背包来解决；
4. 二维费用 V1, V2，或限制总物品数 M(相当于第二维费用统一都是 1，总费用限制为 M)：使用二维数组来表示两个费用；
5. 分组背包：N 个物品分为 K 组，每组只能取一个：对于每一组，对于不超过费用 V...0 各种情况，依次尝试选择组内第 i 个物品；
6. 求第 K 优解：背包问题的状态表示为一个 K 个元素的数组，保存前 K 高的解，状态转义时，max() 函数为将两个数组合并之后取前 K 项；

### 基础DP

* POJ 3176: 若干个数摆成三角，每次可以从上一层移动到下一层最近的两个点，求自顶向下的路径和最大值；每一行所有可能到达的点，其最大值为上一行可达点的最大值加本点；
* POJ 2229: 将一个数 n 分解为 2 的次幂的和，求分解方案数；若为奇数，则方案数为 n+1 分解方案数；若为偶数，则方案数为 n-2 和 n/2 两个数分解方案数之和；
* POJ 2385: 苹果每分钟从两棵树的其中一棵落下，在树 1 和树 2 间可以跳换给定 N 次，问最多可以接到多少苹果，初始在树 1；对每分钟，考虑前一分钟跳换 j 或 j - 1 次；
* POJ 3616: N 个时间区间每个区间包含一个价值，选中的任意两个区间间相隔至少 R，求最大价值；区间按结束时间排序，从后往前，对该区间，求相隔 R 及以上前面区间最大值；
* POJ 3280: 给定字符串任意位置可以增加或删除字符，已知每个字符增删代价，求字符串变回文的最小代价；增删代价取最小，对每一个可能的对称轴，向左右发展；

### 优化递推式

* POJ 1742: 每种面值 A[i] 的硬币各有 C[i] 个，求构成不大于 M 的面值可能性；是一个多重背包问题，用数组 f[i][v] 表示考虑到硬币 i 时，构成面值 v 是否可能；
* POJ 3046, 3181: 都是背包问题的变形；

# Algorithms 4e

1. GCD: Euclid's Algorithm, 循环大数除小数
2. SQRT: Newton's Method, 循环 xNew = ( xOld + x/xOld )/2，直至 xOld 和 x/xOld 相差小于阈值
3. Arithmetic Expression (((2 - 5) + 1) * 2): Dijkstra's Double Stack, 一个操作符栈，一个操作数栈，可转后缀表达式
4. Editor Buffer: 支持插入删除左移右移, 用两个栈头对头，左右移动时一个栈出一个栈进
5. Reverse a Linked List: 开一个新链表头，模拟旧链表出栈新链表入栈；可以用递归
6. 调和级数 1 + 1/2 + 1/3 + ... + 1/N ~ lnN
7. 斯特灵估计 lgN! ~ NlgN，该估计从斯特灵公式得来
8. 二项式系数，当 k 相对小时 C(N, k) ~ N^k/k!，其中 N(N-1)(N-2)...(N-k+1) ~ N^k
9. (1-1/x)^x ~ 1/e
10. 一维数组 N 个不同的数字，找到一个局部最小值：使用二分搜索，因为若中点非局部最小，则小的一侧至少存在一个局部最小；
11. 测试鸡蛋从几层楼摔下不会破的问题，如果鸡蛋很多，可以二分搜索；如果只有两个鸡蛋，可以按照 sqrt(N), 2sqrt(N), ..., sqrt(N)sqrt(N) 测试第一个，测到底线之后另一个线性扔；
12. 选择排序和插入排序，前者运行时间和输入顺序无关，后者在输入基本有序的情况下更优；输入基本有序时，优先考虑插入排序；
13. Shell 排序是插入排序的一个扩展，每次把相隔 h 的元素组成的子序列排序，大循环内减少 h，当 h 为 1 时全局就已排序；h 可以选择 h=3h+1 这样的序列递减；
14. MergeSort 需要一块额外数组，轮换角色法可以减少数组来回拷贝次数；另一个优化是子数组长度小时，使用插入排序，一般长度小于 15 时使用插入排序；Merge 之前检查要 Merge 两个数组，如果一个的最大值小于另一个的最小值，则可以省去一次 Merge；
15. MergeSort 复杂度可以用比较的次数来衡量，每次循环比较次数上限均为 N，循环次数为 lgN，因此复杂度 NlgN；此外，基于比较的排序比较次数不能低于 NlgN；
16. 自底向上写循环进行归并排序，每 2、4、8... 分组依次向上归并，还可以处理链表的排序；还可以使用一个队列，初始队列中是 N 个队列，各含一个元素，循环每次取前两个队列合并；
17. QuickSort 和 MergeSort 相比：前者先按照参考值把数组划分成两部分，然后递归排序两部分；后者先对半划分，然后递归排序两部分，最后合并两部分；
18. QuickSort 的最优情况是每次参考值恰好把数组对半分；几个优化：长度小的数组用插入排序，或忽略小数组，最后统一插入排序一次；每次选取一个小样本，用样本中值作为参考值；
19. 对于存在大量重复 Key 的情况，QuickSort 的一个优化是进行三路分区，选取参考值后，将数组分为小于、等于、大于三部分；3-Way QuickSort 通常是排序库函数实现；
20. 用栈来实现非递归的 QuickSort，每次 Devide 之后，把大小两个子数组压栈，中间压入参考值；
21. 用数组表示的完全二叉树实现大顶、小顶堆，从下标 1 开始存数据编码方便很多，实现优先队列 PQ 很方便；
22. Index PQ 实现 N 路 stream 归并：用大小为 N 的 PQ，每一路 stream 存一个元素进来，每次输出堆顶元素之后，再从对应 stream 里读新元素进来；
23. 堆排序过程：自右向左，从 N/2 到 1 为堆顶，用 sink() 构造大顶堆；然后每次取出堆顶元素放在堆末尾，堆大小减一，原来末尾的元素放在堆顶进行 sink()；

