# ACW

## 穷竭搜索

1. 深度优先搜索，用栈来模拟，或者递归；
2. 广度优先搜索，用队列来模拟；

### 深度优先搜索

* POJ 1979: 长方形地图分隔成方块，方块涂成红黑两色，人初始在黑块上，不能踩红块，计算所有能到达的点；深度、广度搜索；
* AOJ 0118: M * N 矩阵种满植物，相邻同种植物可以划归到一起，求总共能划成几块；从未划归的点开始深度搜索，上下左右相邻同种植物皆标记为当前块；
* AOJ 0033: 1 到 10 编号的 10 个球给定顺序，依次落入两个队列中，问是否存在最终两个队列都是小球在大球之上的方案；贪心算法，优先落在较大队列上；
* POJ 3009: 长方形地图内有障碍，有初始点与终止点，球可四个方向无摩擦运动直至：1. 遇到障碍停下，打碎障碍；2. 出界；3. 终点，求到达终点最少抛掷次数；深度优先搜索；

### 宽度优先搜索

* AOJ 0558: M * N 矩阵中有 K 个点编号 1 至 K，求从起点顺序经历 1 到 K 各点最短路径；任意两点之间都使用广度优先找到最短路径；
* POJ 3669: 给出 M 个流星的落点坐标和时间，流星会摧毁落点和上下左右四点，从原点出发，求安全撤离路径；按照步数广度优先搜索，直至一个平安点；
* AOJ 0121: 0 到 7 八个数字排两行，初始任意局面，走一步为 0 和相邻数字交换，求最终形成上 0123 下 4567 局面的最小步数；从初始局面开始，广度遍历所有局面；

### 穷竭搜索

* POJ 2718: 一组不重复的数字，可将其分为两组组成两个数字，求两个数字最小的差；用递归求数字的全排列，每一个排列从中间劈成两半，求两数差；
* POJ 3187: 给出 1 到 N 共 N 个数的排列，循环求相邻两数之和，直至剩一个数；给定 N 和最后这个数，求 1 至 N 的排列；遍历全排列；
* POJ 3050: 5 * 5 的数字矩阵，求从任意点出发走 6 步，总共能得到几个不同的数；对每一个点，深度遍历所有可能的路径，组合到的数字加入集合；
* AOJ 0525: R * C 矩阵，R <= 10，每个位置为 0 或 1，可以对整行或整列进行反转，求最多可以有多少个 0；由于 R 小，对 R 进行翻与不翻的全排列，每个排列中列调整为 0 最多；

## 贪心算法

### 区间贪心

* POJ 2376: T 个区间，用 N 个区间段覆盖，求最小区间段个数能全部覆盖；将区间段按照开头排序，从最左端开始，贪心取能覆盖左端且最右的区间段；
* POJ 1328: x 轴上方 n 个岛，x 轴上放置半径为 d 的雷达，求覆盖所有岛最少雷达数；n 个岛换算成 x 轴上 n 个区间，按照区间右端排序，从左到右安装雷达；
* POJ 3190: n 头牛各自有产奶区间，产奶时必须独占牛栏，求最少牛栏数；将产奶时间按开始时间排序，按占用牛栏截止时间将牛栏组织在优先队列里，优先安排已释放牛栏，否则新建；

### 其他贪心

* POJ 2393: 给定每天产奶成本，每天需求量，存储一份牛奶一天的固定花费 S，求最小成本的生产计划；每天对比当天或前面 N 天生产本日需求的成本取最小，最终成本即最小；
* POJ 1017: 给出边长为 1 至 6 的正方形若干，求用最少的边长为 6 的正方形装下他们；从大到小六个数字分别处理，每次装箱都尽量贪心装最多；
* POJ 3040: 给出不同面值的硬币，小面值总是可以整除大面值，给出每日花费常量，硬币不可分割，求可支付多少日；每次优先拿不超过 C 的大硬币，若不足则从小到大拿硬币来补；
* POJ 1862: n 个细胞，质量为 m1 m2 的结合后会变成质量为 2 * sqrt(m1 * m2) 的新细胞，求最后形成的终极细胞的最小质量；每次拿最大的两个来结合；
* POJ 3262: 每头牛牵回牛棚需要不同的时间，在回去前单位时间会破坏不同数量的草，求最少破坏多少草；每次选择一个牛，使得牵回它时整体破坏最少；

## 动态规划

### 基础DP

* POJ 3176: 若干个数摆成三角，每次可以从上一层移动到下一层最近的两个点，求自顶向下的路径和最大值；每一行所有可能到达的点，其最大值为上一行可达点的最大值加本点；
* POJ 2229: 将一个数 n 分解为 2 的次幂的和，求分解方案数；若为奇数，则方案数为 n+1 分解方案数；若为偶数，则方案数为 n-2 和 n/2 两个数分解方案数之和；
* POJ 2385: 苹果每分钟从两棵树的其中一棵落下，在树 1 和树 2 间可以跳换给定 N 次，问最多可以接到多少苹果，初始在树 1；对每分钟，考虑前一分钟跳换 j 或 j - 1 次；
* POJ 3616: N 个时间区间每个区间包含一个价值，选中的任意两个区间间相隔至少 R，求最大价值；区间按结束时间排序，从后往前，对该区间，求相隔 R 及以上前面区间最大值；
* POJ 3280: 给定字符串任意位置可以增加或删除字符，已知每个字符增删代价，求字符串变回文的最小代价；增删代价取最小，对每一个可能的对称轴，向左右发展；

### 优化递推式

* POJ 1742: Coins

# Algorithms 4e

1. GCD: Euclid's Algorithm, 循环大数除小数
2. SQRT: Newton's Method, 循环 xNew = ( xOld + x/xOld )/2，直至 xOld 和 x/xOld 相差小于阈值
3. Arithmetic Expression (((2 - 5) + 1) * 2): Dijkstra's Double Stack, 一个操作符栈，一个操作数栈，可转后缀表达式
4. Editor Buffer: 支持插入删除左移右移, 用两个栈头对头，左右移动时一个栈出一个栈进
5. Reverse a Linked List: 开一个新链表头，模拟旧链表出栈新链表入栈；可以用递归
6. 调和级数 1 + 1/2 + 1/3 + ... + 1/N ~ lnN
7. 斯特灵估计 lgN! ~ NlgN，该估计从斯特灵公式得来
8. 二项式系数，当 k 相对小时 C(N, k) ~ N^k/k!，其中 N(N-1)(N-2)...(N-k+1) ~ N^k
9. (1-1/x)^x ~ 1/e

