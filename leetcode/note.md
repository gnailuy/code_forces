# LeetCode

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；
13. 寻找最长无重复字符的子串：使用滑动窗口追踪当前符合要求的子字符串，用一个 HashMap 保存每个字符最新的 Index，单遍扫描 O(n) 时间即可；
14. 寻找最长回文子串：每个中点向外扩展法，O(n^2)；动态规划法，p[i][j] 表示 i 到 j 是否回文，可从 p[i+1][j-1] 算得，按照字串长度循环；
15. 单链表，奇数编号节点全放前面，偶数编号节点全放后边：用两个指针指向当前全奇数节点最后一个节点和全偶数节点最后一个节点，每交换到前面一个节点，advance 指针各一步；
16. 寻找两个单链表的交叉点：首先找到两个链表长度，两个指针指向链表头，长链表的指针先前移到和短链表剩余长度一致，然后一起前移，直至两个指针指向同一个节点；
17. 寻找 BST 排名第 K 的元素: 用递归进行 inorder 遍历，用一个引用型的参数追踪当前节点排名，在中序遇到节点时给这个参数引用的对象加一，遇到 K 时候返回节点的值；
18. Inorder Successor 节点: 先找节点，不要用递归，如果有右子树，返回右子树最小；如果没有右子树：如果有 Parent 指针，向上回溯到第一个向左指向当前节点的父节点；如果没有 Parent 指针，在向下找节点的时候，保存一个 Successor 指针，向左走时候 Successor 跟随，向右走时候 Successor 不动；
19. 生成合法括号对：递归生成，每次递归在已有 prefix 上增加左括号或右括号，左括号使 balance+1，右括号使 balance-1，balance 小于 0 则跳出递归，合法的串加入参数或全局 List；
20. 生成全排列：循环考虑每一位，每一位固定之后，递归考虑后面部分的全排列；

# Google

## 非负数字序列，每个数字前可选 + 号或 - 号，求得到结果 S 的组合数

1. 用 DFS 来搜索解空间，依次考虑每个数字，实现递归算法；可以预先求得一个 i 以及 i 之后数字和的数组，用来在搜索中直接剪枝
2. Dynamic Programming: 考虑前 n-1 位数，dp[n, S]=dp[n-1, S+num[n]] + dp[n-1, S-num[n]]，依次往前类推

## 给定 mxn 数组，1 表示房子，0 表示空地，求一个空地建邮局，距离所有房子最近

1. 把所有房子 Scan 出来成两个数组，一个数组表示 x 坐标，另一个数组表示 y 坐标；扫描所有空地 (i, j)，对每个空地扫描房子数组，计算距离使用 abs(i-x)+abs(j-y)

## 给定若干包含 01 的字符串，给定 m 个 0 和 n 个 1，求最多能组成多少个给定字符串

1. 假设有 k 个字符串，dp[k, m, n]=max(dp[k-1, m-k0, n-k1]+1, dp[k-1, m, n])

## 验证 UTF-8

UTF-8 是变长编码，包括：0 开头的 8 位码，110 开头的 8 位码 + 10 开头的 8 位码；1110 开头的 8 位码 + 两个 10 开头的 8 位码；11110 开头的 8 位码 + 三个 10 开头的 8 位码

1. 每 8 位是一个数字，如果 11110 开头，那么验证后三个并后移四个数字，如果 1110 开头则验证后两个并后移三个数字，以此类推

## 一个整数数据流，持续来数字，动态求 Median

1. 维护两个堆，一个小顶堆保存前一半数据，一个大顶堆保存后一半数据，来新数据时，对比堆顶看看放在哪个堆里，同时维护两个堆的 Size 保持最多相差 1

## 一个二进制手表，四位表示 12 小时，六位表示 60 分钟，给出 1 的个数，求可能的时间值

1. 数据量非常小，可以直接预处理所有的时间可能性，把数据存下来即可

## 给出一组形如 A/B=k 的等式，A 和 B 是变量，k 是实数，求 M/N 是否可解，不可解的话给出 -1

1. 将 A B 等变量作为顶点，做一个有向图，边的权重为 k 和 1/k；M N 直接若联通，则可解，按路径依次代入即可，不联通则不可解

# 其他

* 单链表 Dummy Head，可以减少一个边界检查
* 单链表快慢指针，用于找到中间点，环检测等；如果有环，从 head 和 slow 分别单步，可找到环所在的点
* 两个字符串判断是否 right rotate 关系，其中一个字符串自己拼接自己编程一个长串，然后另一个字符串 indexOf
* NestedInteger Parser(385): 用一个栈，遇到左括号压新 NestedInteger 入栈，遇到右括号弹出 NestedInteger 并作为元素加入栈顶 NestedInteger，遇到数字读数字加入栈顶
* 方阵旋转 90 度，先转置，再翻转
* Rotated Sorted Array 寻找最小：没有重复元素的情况下，可以用二分，中间值和第一个值对比，决定在哪个区间继续寻找
* 有序(自左至右自上至下)二维数组搜索，从右上角开始判断，可以整行或整列排除
* 二叉树最低公共祖先：递归查找，如果当前节点等于任意节点，返回；否则分别查找左右子树，如果左右子树任意子树查找为空，则查找另一侧子树；如果两边各查到一个，则当前返回当前节点；
* 二叉树节点的最大距离：最大距离两种可能，一种是经过当前 Root，那就是左右子树深度相加，另一种是不经过当前 Root，那就是左子树上递归和右子树上递归，取最大；
* 二叉查找树寻找比给定节点大的下一个节点：递归查找，如果当前节点是指定节点，返回右子树最小(可能为空)；否则如果当前节点大于指定节点，在左子树递归，如果返回空就返回当前节点；如果当前节点小于指定节点，返回右子树递归查找的结果；
* 二叉查找树，每个节点改为比该节点大的所有节点之和：先右再左中序遍历，遍历左子树时，节点加上根节点和右子树之和；
* 用 Segment Tree 来快速查询数组任意区间的最小值：递归构建区间树，每个节点保存区间范围，子树最小值；递归查询，分区间在左子树、右子树或者跨树三种情况
* 树的 Amplitude：每条路径路径最大值最小值之差的最大值，递归传入当前最大最小，到叶节点返回，非叶节点递归左右两边，求最大
* Window Minimum: 给定窗口大小 K，在数组上从左至右滑动，求每一步窗口内最小值：使用一个 Deque 保存窗口元素索引，每次右移从左端删掉元素，并且从右端删掉比当前元素大的所有元素，再把当前元素从右边入队列
* 给定一个数组，寻找 slice 中三元素及以上的 arithmetic sequence，对于一个三元素的 slice，找齐所有后续合法的元素计数，然后从最后一个元素重新开始 scan
* Largest Rectangular Area in a Histogram: 普通 O(n^2) 方法暴力；通过区间最低 Bar Divide and Conquer O(nlogn) 方法；一个 O(n) 方法，使用栈依次压入每个 Bar，当遇到比前一个 Bar 小的 Bar，就从前一个 Bar 开始出栈，每次计算以出栈 Bar 为最低点的区域大小；
* Polite Number: 给定一个数，求把这个数表示为连续整数之和的方法：1. 暴力法；2. 滑动窗口法；3. 还有一个利用因式分解的方法，网上有证明

