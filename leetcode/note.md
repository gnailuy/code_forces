# LeetCode

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；
13. 寻找最长无重复字符的子串：使用滑动窗口追踪当前符合要求的子字符串，用一个 HashMap 保存每个字符最新的 Index，单遍扫描 O(n) 时间即可；
14. 寻找最长回文子串：每个中点向外扩展法，O(n^2)；动态规划法，p[i][j] 表示 i 到 j 是否回文，可从 p[i+1][j-1] 算得，按照字串长度循环；

# Google

## 非负数字序列，每个数字前可选 + 号或 - 号，求得到结果 S 的组合数

1. 用 DFS 来搜索解空间，依次考虑每个数字，实现递归算法；可以预先求得一个 i 以及 i 之后数字和的数组，用来在搜索中直接剪枝
2. Dynamic Programming: 考虑前 n-1 位数，dp[n, S]=dp[n-1, S+num[n]] + dp[n-1, S-num[n]]，依次往前类推

## 给定 mxn 数组，1 表示房子，0 表示空地，求一个空地建邮局，距离所有房子最近

1. 把所有房子 Scan 出来成两个数组，一个数组表示 x 坐标，另一个数组表示 y 坐标；扫描所有空地 (i, j)，对每个空地扫描房子数组，计算距离使用 abs(i-x)+abs(j-y)

## 给定若干包含 01 的字符串，给定 m 个 0 和 n 个 1，求最多能组成多少个给定字符串

1. 假设有 k 个字符串，dp[k, m, n]=max(dp[k-1, m-k0, n-k1]+1, dp[k-1, m, n])

## 验证 UTF-8

UTF-8 是变长编码，包括：0 开头的 8 位码，110 开头的 8 位码 + 10 开头的 8 位码；1110 开头的 8 位码 + 两个 10 开头的 8 位码；11110 开头的 8 位码 + 三个 10 开头的 8 位码

1. 每 8 位是一个数字，如果 11110 开头，那么验证后三个并后移四个数字，如果 1110 开头则验证后两个并后移三个数字，以此类推

## 一个整数数据流，持续来数字，动态求 Median

1. 维护两个堆，一个小顶堆保存前一半数据，一个大顶堆保存后一半数据，来新数据时，对比堆顶看看放在哪个堆里，同时维护两个堆的 Size 保持最多相差 1

## 一个二进制手表，四位表示 12 小时，六位表示 60 分钟，给出 1 的个数，求可能的时间值

1. 数据量非常小，可以直接预处理所有的时间可能性，把数据存下来即可

## 给出一组形如 A/B=k 的等式，A 和 B 是变量，k 是实数，求 M/N 是否可解，不可解的话给出 -1

1. 将 A B 等变量作为顶点，做一个有向图，边的权重为 k 和 1/k；M N 直接若联通，则可解，按路径依次代入即可，不联通则不可解

# 其他

* 单链表 Dummy Head，可以减少一个边界检查
* 单链表快慢指针，用于找到中间点，环检测等；如果有环，从 head 和 slow 分别单步，可找到环所在的点
* 两个字符串判断是否 right rotate 关系，其中一个字符串自己拼接自己编程一个长串，然后另一个字符串 indexOf
* NestedInteger Parser(385): 用一个栈，遇到左括号压新 NestedInteger 入栈，遇到右括号弹出 NestedInteger 并作为元素加入栈顶 NestedInteger，遇到数字读数字加入栈顶
* 方阵旋转 90 度，先转置，再翻转
* 有序(自左至右自上至下)二维数组搜索，从右上角开始判断，可以整行或整列排除
* 二叉树最低公共祖先：递归查找，如果当前节点等于任意节点，返回；否则分别查找左右子树，如果左右子树任意子树查找为空，则查找另一侧子树；如果两边各查到一个，则当前返回当前节点；
* 二叉树节点的最大距离：最大距离两种可能，一种是经过当前 Root，那就是左右子树深度相加，另一种是不经过当前 Root，那就是左子树上递归和右子树上递归，取最大；
* 二叉查找树寻找比给定节点大的下一个节点：递归查找，如果当前节点是指定节点，返回右子树最小(可能为空)；否则如果当前节点大于指定节点，在左子树递归，如果返回空就返回当前节点；如果当前节点小于指定节点，返回右子树递归查找的结果；
* 用 Segment Tree 来快速查询数组任意区间的最小值：递归构建区间树，每个节点保存区间范围，子树最小值；递归查询，分区间在左子树、右子树或者跨树三种情况
* 树的 Amplitude：每条路径路径最大值最小值之差的最大值，递归传入当前最大最小，到叶节点返回，非叶节点递归左右两边，求最大
* Window Minimum: 给定窗口大小 K，在数组上从左至右滑动，求每一步窗口内最小值：使用一个 Deque 保存窗口元素索引，每次右移从左端删掉元素，并且从右端删掉比当前元素大的所有元素，再把当前元素从右边入队列
* 给定一个数组，寻找 slice 中三元素及以上的 arithmetic sequence，对于一个三元素的 slice，找齐所有后续合法的元素计数，然后从最后一个元素重新开始 scan
* Largest Rectangular Area in a Histogram: 普通 O(n^2) 方法暴力；通过区间最低 Bar Divide and Conquer O(nlogn) 方法；一个 O(n) 方法，使用栈依次压入每个 Bar，当遇到比前一个 Bar 小的 Bar，就从前一个 Bar 开始出栈，每次计算以出栈 Bar 为最低点的区域大小；

