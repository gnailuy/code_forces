# LeetCode

## Easy and Medium

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历，如果负数导致前面整体加和为负，则从后面的整数重新开始累加；注意全负数的情况；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；
13. 寻找最长无重复字符的子串：使用滑动窗口追踪当前符合要求的子字符串，用一个 HashMap 保存每个字符最新的 Index，单遍扫描 O(n) 时间即可；
14. 寻找最长回文子串：每个中点向外扩展法，O(n^2)；动态规划法，p[i][j] 表示 i 到 j 是否回文，可从 p[i+1][j-1] 算得，按照字串长度循环；
15. 单链表，奇数编号节点全放前面，偶数编号节点全放后边：用两个指针指向当前全奇数节点最后一个节点和全偶数节点最后一个节点，每交换到前面一个节点，advance 指针各一步；
16. 寻找两个单链表的交叉点：首先找到两个链表长度，两个指针指向链表头，长链表的指针先前移到和短链表剩余长度一致，然后一起前移，直至两个指针指向同一个节点；
17. 寻找 BST 排名第 K 的元素: 用递归进行 inorder 遍历，用一个引用型的参数追踪当前节点排名，在中序遇到节点时给这个参数引用的对象加一，遇到 K 时候返回节点的值；
18. Inorder Successor 节点: 先找节点，不要用递归，如果有右子树，返回右子树最小；如果没有右子树：如果有 Parent 指针，向上回溯到第一个向左指向当前节点的父节点；如果没有 Parent 指针，在向下找节点的时候，保存一个 Successor 指针，向左走时候 Successor 跟随，向右走时候 Successor 不动；
19. 生成合法括号对：递归生成，每次递归在已有 prefix 上增加左括号或右括号，左括号使 balance+1，右括号使 balance-1，balance 小于 0 则跳出递归，合法的串加入参数或全局 List；
20. 生成全排列：循环考虑每一位，每一位固定之后(可以交换到数组指定位置，递归调用后再复原，Backtracking)，递归考虑后面部分的全排列；
21. 生成组合：递归调用，追踪当前考虑的 index，尝试将 index 及以后元素 i 依次加入，每次加入一个元素后递归调用 i+1，调用完毕后把元素 i 从组合中取出；拷贝输出；
22. 在矩阵中搜索 Word，用 dfs 搜索，用一个 visited 数组表示当前位置是否已经访问过，退出 dfs 时还原当前节点的 visited 标记；
23. 三种元素排序：计数排序；普通排序；用 ijk 三个指针分别指向当前 0 的下一个元素，1 的下一个元素，2 的前一个元素，循环 j，如果为 0 则和 i 交换，如果为 2 则和 k 交换，如果为 1 则指针后移；要注意 ij 相等的时候，如果遇到 0，则 ij 一起后移；
24. 寻找数组中第 K 大的元素，使用快排类似的 Partition 方法，若左侧分区大小大于 K，则继续在左侧找，否则在右侧找，K 减去左侧分区的大小；注意数组分区时候下标的变化；
25. 寻找数组中的 Peak Number：使用二分查找类似的办法，如果当前节点不是 Peak，那么如果它小于左侧节点，左边一定有 Peak，否则右边一定有 Peak，返回任意一个即可；
26. 寻找数组中 target 的左右范围：使用两个二分查找，一个查找 x < target 这样的序列，另一个查找 target < y 这样的序列，分别为左右 Index；
27. 合并相邻区间，先把区间按照开始点排序，然后依次比较当前区间结束点和下一区间开始点，注意有可能下一区间完全包含在当前区间内，这时不需要更新结束点；
28. Rotated Sorted 数组查找 target：二分查找分四种情况，分解点在中点左边或右边，目标在中点左边或右边；或者先二分找到数组最小值，然后在最小值左边或右边二分查找；
29. 二叉树序列化和反序列化：类似分层遍历，使用一个 Queue 来追踪层数保持顺序，如果某个子节点为空，则在输出流中输出一个空字符串标记；
30. 给定数字 n，求 n 的阶乘结果中结尾 0 的个数：需要数素因子中 2 和 5 的个数，5 的个数少，因此只数 5 的个数即可，每 5 个数数一下即可；
31. 计算 x^n，其中 x ~ [-100, 100], n ~ [MIN_VALUE, MAX_VALUE]：根据 x 和 n 计算符号，先把 x 和 n 都换成正数，循环计算时如果结果归零，或者要超过整数上限，则直接返回；
32. 不用乘除模运算符，计算两整数除法：先计算结果的符号，然后考虑到负数范围比正数大，把两个数都转换为负数，每次尝试从 dividend 中减去 divisor 的最大左移值(1, 2, 4, ... 个)；
33. 分数表示为循环小数：需要处理 MIN_VALUE/1 和 MIN_VALUE/-1 两种特殊情况，然后还是计算符号，把数转为负数，用 Long 表示被除数的余，每次乘 10 不会溢出；StringBuilder.insert() 可以用于插入左括号；
34. 不用加减号两数相加：首先考虑 MIN_VALUE-n 和 MAX_VALUE+n 溢出，特殊处理；然后按位自右向左处理，考虑两数每一位和 carry 的情况，决定结果中该位的值和 carry；
35. 编号 1 到 n 的人，其中有一个或零个 Celebrity，他不认识任何人，但所有人都认识他，只能一一询问 A knows B?，找到名人：因为每对比两个人，都可以 rule out 其中一个，因此可以用双指针，一个初始在开头，一个初始在结尾，每次对比 rule out 一个人，指针往中间移动；最后还得验证一下双指针合并之后指向这个人是不是名人；复杂度更高的算法，可以用图；
36. 带冷却时间的任务调度：按照任务数量从大到小调度，每调度一个任务，记录其运行时间，放入 Cooling Down 队列，并且从 Cooling Down 队列唤醒其他冷却好的任务；如果任务队列耗尽，则直接从 Cooling Down 队列取头一个任务运行；

## Weekly

1. ZigZag Conversion@6: 给定字符串，求按字符之字形排列后，再横向读取的新字符串：需要考虑之字高度为 1 和 2 的特殊情况，之字高度大于 2 时，每次排 2h+2 个字符；
2. Palindrome Number@9: 判断给定整数是不是回文，不能转成字符串来判断：首先负数肯定不是，零肯定是，正数的话，先转换成 long，然后每次模 10 取最后一位，构造倒过来的数字；
3. Integer to Roman@12: 整数变罗马数字，按照 1000, 900, 500, 400, ..., 5, 4, 1 这样把所有可能的值对应成 M, CM, D, CD, ..., V, IV, I 这样的元素，从高到低从整数里拿出值来；
4. 3Sum Closest@16: 类似 3Sum，但是找离 Target 最近的组合：先排序，循环 i 和 j 两个数，在 j+1 到数组结束这个范围内，二分查找使离 Target 最接近的 k 这个数；复杂度 n^2\*lgn；
5. 4Sum@18: n^3\*lgn 的办法可以接受，先排序数组，前三个遍历选取，最后一个二分查找；
6. Swap Nodes in Pairs@24: 给定链表，每两个节点交换位置，如 1 2 3 4，得到 2 1 4 3；设置一个 dummy node 放在 head 前面，这样后面的交换逻辑好写；
7. Reverse Nodes in k-Group@25: 给定链表，每 K 个节点的子链翻转，最后不足 K 个的不管；还是设置个 dummy node，然后每数 K 个节点，记录前序、后续链表指针，翻转然后重新组装；
8. Substring With Concatenation of All Words@30: 给定字符串 s，和一个等长字符串的数组 words，求数组中所有字符串组合，是否是 s 的子串；利用数组中字符串等长这个特点，滑动窗口考察所有 words[0].length()\*words.length 这样长度的 s 的子串，如果每隔 words[0].length() 这样的距离，都是 words 中的合法 word，那么字串就符合要求；考虑到数组中重复的字符串，可以用一个 WordCountMap 来替代数组 words；

## Hard

1. 给定一个数组，求除了当前位置外其他元素之积，要求不用除法，最好不用额外空间：从前往后遍历数组，计算当前位置之前的乘积；然后从后往前遍历，用一个变量累积当前位置之后的乘积，把当前位置之后的乘积和之前的乘积相乘即可；
2. SpiralMatrix：分层遍历，上下左右各自维护一个界限标记，每遍历一边更新上下左右界限；
3. FourSum II：四个整数数组，求各取一个数和为零的取法：先计算前两个的和，放入 HashMap；然后计算后两个的和，从 HashMap 中找到和前两个和凑成 0 的方法数；O(n^2)
4. 给定一个数组 a，对任意下标 i < j，求 min(a[i], a[j]) * (j - i) 的最大值(数组数值为 Bar 高度，求选哪两个 Bar 中间容积最大)：用两个指针从两头往中间走，每次低的一端往中间走，因为如果高的往中间走，容积不可能增加只能减少；
5. Game of Life: 1. 按照规则将下一步状态保存在一个新的数组里面，最后拷贝回原数组；2. 使用 0 和 1 之外的数字表示其他状态，例如 2 表示原来是 0 要变为 1，3 和 2 相反，这样可以不用额外空间；
6. 给定任意数组，寻找第一个缺失的正整数：要点在于，只需要考量数组长度个整数即可，长度 n 的数组，只需要考量 1 到 n 是否存在，因此算法尝试使用原数组对应位置保存 1 到 n 这 n 个整数，最后寻找哪个不就位即可；
7. 给定任意数组，寻找最长连续数字的长度：先把数字加入到一个 HashSet，然后从头遍历数字，对于每个数字创建一个队列，尝试把判断其前后两个数字在不在 Set 里，在的话加入队列，直到队列为空，这个队列里走过的元素就是一个连续数字串长度；
8. 长度为 n+1 的数组保存范围 1 到 n 的数字，只有一个数字有重复(可能重复多次)，找到这个数：排序 nlogn，Set 占空间，把问题 reduce 到链表求环，让每个数字指向数字作为下标的下一个数字，可以用快慢指针解决；
9. 滑动窗口最大：使用一个 deque，在滑动窗口滑动时，移除右侧比要加入元素小的元素；
10. 整数矩阵中的最长递增序列：初始化一个 longestIncreasingPath 数组，全为 0；遍历所有元素，对于一个元素，如果它周围都比它小，则 lip 为 1；否则，递归计算比它大的元素 lip，然后把它的 lip 赋值为所有比它大的元素 lip 的最大值加一；
11. 给定乱序数组，求每个元素在其右侧比它小的元素个数：要点在于从右向左考虑，维护右侧所有元素于一个排序集合、二叉查找树、红黑数等结构，可以快速找到右侧元素集合中比当前元素小的元素；
12. 给定字符串，求所有可能的分割方式，使得所有分割出来的子串都是回文：从字符串左侧开始，向右寻找存在的回文；每找到一个回文，就加入当前分割的列表，然后从这个回文右边开始递归，递归结束之后把当前回文删掉，继续循环；当递归调用遇到字符串结尾时，把当前分割加入结果集合；
13. 给定一个含小括号和任意其他字符的字符串，求最少删除多少个小括号，可以使得小括号能够成对匹配，要求输出所有方案：BFS 搜索，每一步判断删除某个括号能不能形成匹配；或者从前向后搜索，每遇到一个左括号，考虑它被删，或者不被删，依次匹配右边所有右括号；
14. 给定一个乱序数组，求一个顺序 k 使得 k0 < k1 > k2 < k3 > k4 ...，保证结果存在：先排序，为了让最接近的中部元素离得远一点，把前半部分倒排到奇数位，后半部分正排到偶数位；
15. 给定一个已排序 nxn 二维数组，每行从小到大，每列从小到大，求第 k 个元素：从左上角最小的元素开始，每添加一个元素，其右侧和下方元素被加入优先队列，每次取最小的一个元素；
16. 给定一个数组，求用这些数的字符串形式组合出的最大数字的字符串形式：自定义 Comparator，对于字符串 a 和 b，根据 a+b 和 b+a 的大小排序，然后对字符串数组排序即可；

# 收集的一些题

* 单链表 Dummy Head，可以减少一个边界检查
* 单链表快慢指针，用于找到中间点，环检测等；如果有环，从 head 和 slow 分别单步，可找到环所在的点
* 两个字符串判断是否 right rotate 关系，其中一个字符串自己拼接自己编程一个长串，然后另一个字符串 indexOf
* NestedInteger Parser(385): 用一个栈，遇到左括号压新 NestedInteger 入栈，遇到右括号弹出 NestedInteger 并作为元素加入栈顶 NestedInteger，遇到数字读数字加入栈顶
* 方阵旋转 90 度，先转置，再翻转
* Rotated Sorted Array 寻找最小：没有重复元素的情况下，可以用二分，中间值和第一个值对比，决定在哪个区间继续寻找
* 有序(自左至右自上至下)二维数组搜索，从右上角开始判断，可以整行或整列排除
* 二叉树最低公共祖先：递归查找，如果当前节点等于任意节点，返回；否则分别查找左右子树，如果左右子树任意子树查找为空，则查找另一侧子树；如果两边各查到一个，则当前返回当前节点；
* 二叉树节点的最大距离：最大距离两种可能，一种是经过当前 Root，那就是左右子树深度相加，另一种是不经过当前 Root，那就是左子树上递归和右子树上递归，取最大；
* 二叉树 Vertical Sum：二叉树从根节点定义为 0，往左一个节点减一，往右一个节点加一，求各个竖直线上的元素和：遍历树，计算各个节点的值，相同值的在同一个竖直线上，用 Map 求和；
* 二叉树的最大宽度：用一个 Queue 分层遍历一个树，每一层求一个宽度，取最大值；
* 二叉查找树寻找比给定节点大的下一个节点：递归查找，如果当前节点是指定节点，返回右子树最小(可能为空)；否则如果当前节点大于指定节点，在左子树递归，如果返回空就返回当前节点；如果当前节点小于指定节点，返回右子树递归查找的结果；
* 二叉查找树，每个节点改为比该节点大的所有节点之和：先右再左中序遍历，遍历左子树时，节点加上根节点和右子树之和；
* 用 Segment Tree 来快速查询数组任意区间的最小值：递归构建区间树，每个节点保存区间范围，子树最小值；递归查询，分区间在左子树、右子树或者跨树三种情况
* 树的 Amplitude：每条路径路径最大值最小值之差的最大值，递归传入当前最大最小，到叶节点返回，非叶节点递归左右两边，求最大
* Window Minimum: 给定窗口大小 K，在数组上从左至右滑动，求每一步窗口内最小值：使用一个 Deque 保存窗口元素索引，每次右移从左端删掉元素，并且从右端删掉比当前元素大的所有元素，再把当前元素从右边入队列
* 给定一个数组，寻找 slice 中三元素及以上的 arithmetic sequence，对于一个三元素的 slice，找齐所有后续合法的元素计数，然后从最后一个元素重新开始 scan
* Largest Rectangular Area in a Histogram: 普通 O(n^2) 方法暴力；通过区间最低 Bar Divide and Conquer O(nlogn) 方法；一个 O(n) 方法，使用栈依次压入每个 Bar，当遇到比前一个 Bar 小的 Bar，就从前一个 Bar 开始出栈，每次计算以出栈 Bar 为最低点的区域大小；
* Polite Number: 给定一个数，求把这个数表示为连续整数之和的方法：1. 暴力法；2. 滑动窗口法；3. 还有一个利用因式分解的方法，网上有证明
* 给出一些 Pair，是 Categories 里的父子关系，建立树并打印出来：设置一个 rootSet 和一个 nodeSet，对于每一个 Pair，如果 Node 还不存在，就建立 Node 加入 nodeSet；如果子 Node 已经在 rootSet 里，则取出；然后让父 Node 指向子 Node；最后 rootSet 应该只剩一个 Node，分层遍历即可；

# Google

## 非负数字序列，每个数字前可选 + 号或 - 号，求得到结果 S 的组合数

1. 用 DFS 来搜索解空间，依次考虑每个数字，实现递归算法；可以预先求得一个 i 以及 i 之后数字和的数组，用来在搜索中直接剪枝
2. Dynamic Programming: 考虑前 n-1 位数，dp[n, S]=dp[n-1, S+num[n]] + dp[n-1, S-num[n]]，依次往前类推

## 给定 mxn 数组，1 表示房子，0 表示空地，求一个空地建邮局，距离所有房子最近

1. 把所有房子 Scan 出来成两个数组，一个数组表示 x 坐标，另一个数组表示 y 坐标；扫描所有空地 (i, j)，对每个空地扫描房子数组，计算距离使用 abs(i-x)+abs(j-y)

## 给定若干包含 01 的字符串，给定 m 个 0 和 n 个 1，求最多能组成多少个给定字符串

1. 假设有 k 个字符串，dp[k, m, n]=max(dp[k-1, m-k0, n-k1]+1, dp[k-1, m, n])

## 验证 UTF-8

UTF-8 是变长编码，包括：0 开头的 8 位码，110 开头的 8 位码 + 10 开头的 8 位码；1110 开头的 8 位码 + 两个 10 开头的 8 位码；11110 开头的 8 位码 + 三个 10 开头的 8 位码

1. 每 8 位是一个数字，如果 11110 开头，那么验证后三个并后移四个数字，如果 1110 开头则验证后两个并后移三个数字，以此类推

## 一个整数数据流，持续来数字，动态求 Median

1. 维护两个堆，一个小顶堆保存前一半数据，一个大顶堆保存后一半数据，来新数据时，对比堆顶看看放在哪个堆里，同时维护两个堆的 Size 保持最多相差 1

## 一个二进制手表，四位表示 12 小时，六位表示 60 分钟，给出 1 的个数，求可能的时间值

1. 数据量非常小，可以直接预处理所有的时间可能性，把数据存下来即可

## 给出一组形如 A/B=k 的等式，A 和 B 是变量，k 是实数，求 M/N 是否可解，不可解的话给出 -1

1. 将 A B 等变量作为顶点，做一个有向图，边的权重为 k 和 1/k；M N 直接若联通，则可解，按路径依次代入即可，不联通则不可解

