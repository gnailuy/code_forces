# LeetCode

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；
13. 寻找最长无重复字符的子串：使用滑动窗口追踪当前符合要求的子字符串，用一个 HashMap 保存每个字符最新的 Index，单遍扫描 O(n) 时间即可；
14. 寻找最长回文子串：每个中点向外扩展法，O(n^2)；动态规划法，p[i][j] 表示 i 到 j 是否回文，可从 p[i+1][j-1] 算得，按照字串长度循环；

# Google

## 非负数字序列，每个数字前可选 + 号或 - 号，求得到结果 S 的组合数

1. 用 DFS 来搜索解空间，依次考虑每个数字，实现递归算法；可以预先求得一个 i 以及 i 之后数字和的数组，用来在搜索中直接剪枝
2. Dynamic Programming: 考虑前 n-1 位数，dp[n, S]=dp[n-1, S+num[n]] + dp[n-1, S-num[n]]，依次往前类推

## 给定 mxn 数组，1 表示房子，0 表示空地，求一个空地建邮局，距离所有房子最近

1. 把所有房子 Scan 出来成两个数组，一个数组表示 x 坐标，另一个数组表示 y 坐标；扫描所有空地 (i, j)，对每个空地扫描房子数组，计算距离使用 abs(i-x)+abs(j-y)

## 给定若干包含 01 的字符串，给定 m 个 0 和 n 个 1，求最多能组成多少个给定字符串

1. 假设有 k 个字符串，dp[k, m, n]=max(dp[k-1, m-k0, n-k1]+1, dp[k-1, m, n])

## 验证 UTF-8

UTF-8 是变长编码，包括：0 开头的 8 位码，110 开头的 8 位码 + 10 开头的 8 位码；1110 开头的 8 位码 + 两个 10 开头的 8 位码；11110 开头的 8 位码 + 三个 10 开头的 8 位码

1. 每 8 位是一个数字，如果 11110 开头，那么验证后三个并后移四个数字，如果 1110 开头则验证后两个并后移三个数字，以此类推

## 一个整数数据流，持续来数字，动态求 Median

1. 维护两个堆，一个小顶堆保存前一半数据，一个大顶堆保存后一半数据，来新数据时，对比堆顶看看放在哪个堆里，同时维护两个堆的 Size 保持最多相差 1

## 一个二进制手表，四位表示 12 小时，六位表示 60 分钟，给出 1 的个数，求可能的时间值

1. 数据量非常小，可以直接预处理所有的时间可能性，把数据存下来即可

## 给出一组形如 A/B=k 的等式，A 和 B 是变量，k 是实数，求 M/N 是否可解，不可解的话给出 -1

1. 将 A B 等变量作为顶点，做一个有向图，边的权重为 k 和 1/k；M N 直接若联通，则可解，按路径依次代入即可，不联通则不可解

