# LeetCode

1. awk 的工作模式，BEGIN, 中间代码，END 三段；放在 bash 脚本中时，可以用 -v 参数传入变量；
2. 长度为 N 的数组向右 Rotate k，空间复杂度限制 O(1)，先取 N 和 k 的 GCD，循环 GCD(N, k) 次，每次 Rotate k/GCD(N, k) 步；
3. 列表中除了一个数外，其他数都成对出现，找到单独的数：排序和 HashSet 都可以，最快的办法是用异或，循环把每一个数异或到一起，相同的数异或会抵消为零，独数和零异或不变；
4. 用 LinkedHashMap 实现 LRU Cache，Java 有内置实现，也可以用 HashMap 和一个双向链表合体实现；用 HashMap 实现 Get 和 Set，刚刚访问的元素移到链表一端，需要时从另一端删除；
5. 翻转整数：为了防止溢出，在每次 x 乘 10 之前检查 Integer.MAX\_VALUE / 10 是否大于 x，如果大于 x，则说明 x 乘 10 肯定溢出；
6. 爬楼梯，每次可爬一级或者两级，问总共多少爬法：对于 n 层楼梯，爬到 n 层的爬法 s[n] = s[n-1] + s[n-2]；
7. 最大子数组问题：把连续正数和连续负数加起来，构成一个一正一负这样的数组，从前向后遍历；
8. 一个正整数数组，从中取任意多个数，但不能同时取相邻两个，求能拿到的最大加和：考虑第 i 个元素时：s[i] = max(s[i-1], s[i-2]+v[i])；
9. MinStack，一个栈，支持 push(), pop(), top() 和 getMin()：通过一个额外栈，额外栈上总是保存当前已入栈的最小值，即可 o(1) 取到最小值；
10. 罗马数字变整数：从后向前处理，遇到小于当前最大的减，遇到大于等于当前最大的加；
11. 给定一个 Integer，求其二进制表示中的 1 个数：不要动这个数，不要右移它，不要用取模等算法；用一个 mask 从 1 开始左移，依次跟这个数与运算，看结果是否为零决定；
12. 给定 K 个已排序的数组，求一个最小的 Range，包含每个数组的至少一个元素：从 K 个数组的最小值开始，每次从 K 个值中求出最大最小，作为当前 Range；每一步最小值所在的数组往后移指针，如果找到更小的 Range，更新当前 Range 信息，直至全部数组遍历完毕；可以使用一个 MinHeap 追踪 K 个最小值；
13. 寻找最长无重复字符的子串：使用滑动窗口追踪当前符合要求的子字符串，用一个 HashMap 保存每个字符最新的 Index，单遍扫描 O(n) 时间即可；
14. 寻找最长回文子串：每个中点向外扩展法，O(n^2)；动态规划法，p[i][j] 表示 i 到 j 是否回文，可从 p[i+1][j-1] 算得，按照字串长度循环；

